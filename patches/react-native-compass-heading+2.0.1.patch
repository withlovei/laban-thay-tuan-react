diff --git a/node_modules/react-native-compass-heading/android/src/main/java/com/compassheading/CompassHeadingModule.kt b/node_modules/react-native-compass-heading/android/src/main/java/com/compassheading/CompassHeadingModule.kt
index d2bf0b2..7b191a6 100644
--- a/node_modules/react-native-compass-heading/android/src/main/java/com/compassheading/CompassHeadingModule.kt
+++ b/node_modules/react-native-compass-heading/android/src/main/java/com/compassheading/CompassHeadingModule.kt
@@ -1,19 +1,14 @@
 package com.compassheading
 
-import android.app.Activity
 import android.content.Context
-import android.hardware.Sensor
-import android.hardware.SensorEvent
-import android.hardware.SensorEventListener
-import android.hardware.SensorManager
+import android.hardware.*
 import android.util.Log
-import android.view.Surface
 import android.view.Display
+import android.view.Surface
 import android.view.WindowManager
 import com.facebook.react.bridge.*
 import com.facebook.react.modules.core.DeviceEventManagerModule
 import kotlin.math.abs
-import kotlin.math.PI
 
 class CompassHeadingModule(reactContext: ReactApplicationContext) :
     ReactContextBaseJavaModule(reactContext), SensorEventListener {
@@ -22,42 +17,56 @@ class CompassHeadingModule(reactContext: ReactApplicationContext) :
         const val NAME = "CompassHeading"
     }
 
+    private val appContext: Context = reactContext.applicationContext
     private val mApplicationContext: Context = reactContext.applicationContext
-    private var mAzimuth: Int = 0 // degree
-    private var mFilter: Int = 1
     private var sensorManager: SensorManager? = null
-    private val mGravity = FloatArray(3)
-    private val mGeomagnetic = FloatArray(3)
-    private val R = FloatArray(9)
-    private val I = FloatArray(9)
+    private var rotationVectorSensor: Sensor? = null
+    private var geomagneticRotationVectorSensor: Sensor? = null
+    private var accelerometer: Sensor? = null
+    private var magnetometer: Sensor? = null
+
+    private var azimuth: Double = 0.0
+    private var filterThreshold: Double = 1.0
+    private var gravity = FloatArray(3)
+    private var geomagnetic = FloatArray(3)
+    private var rotationMatrix = FloatArray(9)
+    private var inclinationMatrix = FloatArray(9)
 
     override fun getName(): String {
         return NAME
     }
 
     @ReactMethod
-    fun addListener(eventName: String) {
-        // Required for React Native built-in Event Emitter Calls
-    }
-
-    @ReactMethod
-    fun removeListeners(count: Int) {
-        // Required for React Native built-in Event Emitter Calls
-    }
-
-    @ReactMethod
-    fun start(filter: Int, promise: Promise) {
+    fun start(filter: Double, promise: Promise) {
         try {
-            sensorManager = mApplicationContext.getSystemService(Context.SENSOR_SERVICE) as SensorManager
-            val gsensor = sensorManager?.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
-            val msensor = sensorManager?.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)
-            sensorManager?.registerListener(this, gsensor, SensorManager.SENSOR_DELAY_GAME)
-            sensorManager?.registerListener(this, msensor, SensorManager.SENSOR_DELAY_GAME)
-            mFilter = filter
-            Log.d(NAME, "Compass heading started with filter: $mFilter")
+            sensorManager = appContext.getSystemService(Context.SENSOR_SERVICE) as SensorManager
+
+            // Check for TYPE_GEOMAGNETIC_ROTATION_VECTOR
+            geomagneticRotationVectorSensor =
+                sensorManager?.getDefaultSensor(Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR)
+
+            // If not available, check for TYPE_ROTATION_VECTOR
+            rotationVectorSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_ROTATION_VECTOR)
+
+            // If both rotation vector sensors are not available, use accelerometer and magnetometer
+            if (geomagneticRotationVectorSensor != null) {
+                sensorManager?.registerListener(this, geomagneticRotationVectorSensor, SensorManager.SENSOR_DELAY_UI)
+                Log.d(NAME, "Using TYPE_GEOMAGNETIC_ROTATION_VECTOR for heading.")
+            } else if (rotationVectorSensor != null) {
+                sensorManager?.registerListener(this, rotationVectorSensor, SensorManager.SENSOR_DELAY_UI)
+                Log.d(NAME, "Using TYPE_ROTATION_VECTOR for heading.")
+            } else {
+                accelerometer = sensorManager?.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
+                magnetometer = sensorManager?.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD)
+                sensorManager?.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)
+                sensorManager?.registerListener(this, magnetometer, SensorManager.SENSOR_DELAY_UI)
+                Log.d(NAME, "Using ACCELEROMETER & MAGNETIC_FIELD for heading.")
+            }
+
+            filterThreshold = filter
             promise.resolve(true)
         } catch (e: Exception) {
-            Log.e(NAME, "Failed to start compass heading: ${e.message}")
+            Log.e(NAME, "Failed to start compass: ${e.message}")
             promise.reject("failed_start", e.message)
         }
     }
@@ -65,92 +74,96 @@ class CompassHeadingModule(reactContext: ReactApplicationContext) :
     @ReactMethod
     fun stop() {
         sensorManager?.unregisterListener(this)
-        Log.d(NAME, "Compass heading stopped")
+        Log.d(NAME, "Compass heading stopped.")
     }
 
-    @ReactMethod
-    fun hasCompass(promise: Promise) {
-        try {
-            val manager = mApplicationContext.getSystemService(Context.SENSOR_SERVICE) as SensorManager
-            val hasCompass = manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null &&
-                    manager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD) != null
-            promise.resolve(hasCompass)
-        } catch (e: Exception) {
-            Log.e(NAME, "Error checking for compass: ${e.message}")
-            promise.resolve(false)
+    override fun onSensorChanged(event: SensorEvent) {
+        when (event.sensor.type) {
+            Sensor.TYPE_GEOMAGNETIC_ROTATION_VECTOR -> {
+                processGeomagneticRotationVector(event.values)
+            }
+            Sensor.TYPE_ROTATION_VECTOR -> {
+                processRotationVector(event.values)
+            }
+            Sensor.TYPE_ACCELEROMETER -> {
+                System.arraycopy(event.values, 0, gravity, 0, event.values.size)
+                processCompass()
+            }
+            Sensor.TYPE_MAGNETIC_FIELD -> {
+                System.arraycopy(event.values, 0, geomagnetic, 0, event.values.size)
+                processCompass()
+            }
         }
     }
 
-    override fun onSensorChanged(event: SensorEvent) {
-        val alpha = 0.97f
-        synchronized(this) {
-            when (event.sensor.type) {
-                Sensor.TYPE_ACCELEROMETER -> {
-                    mGravity[0] = alpha * mGravity[0] + (1 - alpha) * event.values[0]
-                    mGravity[1] = alpha * mGravity[1] + (1 - alpha) * event.values[1]
-                    mGravity[2] = alpha * mGravity[2] + (1 - alpha) * event.values[2]
-                }
-                Sensor.TYPE_MAGNETIC_FIELD -> {
-                    mGeomagnetic[0] = alpha * mGeomagnetic[0] + (1 - alpha) * event.values[0]
-                    mGeomagnetic[1] = alpha * mGeomagnetic[1] + (1 - alpha) * event.values[1]
-                    mGeomagnetic[2] = alpha * mGeomagnetic[2] + (1 - alpha) * event.values[2]
-                }
-            }
+    private fun processGeomagneticRotationVector(values: FloatArray) {
+        val adjustedRotationMatrix = FloatArray(9)
+        SensorManager.getRotationMatrixFromVector(adjustedRotationMatrix, values)
+
+        val orientation = FloatArray(3)
+        SensorManager.getOrientation(adjustedRotationMatrix, orientation)
+
+        val newAzimuth = normalizeAzimuth(Math.toDegrees(orientation[0].toDouble()))
+        updateAzimuth(newAzimuth)
+    }
+
+    private fun processRotationVector(values: FloatArray) {
+        val rotationMatrix = FloatArray(9)
+        SensorManager.getRotationMatrixFromVector(rotationMatrix, values)
+
+        val orientation = FloatArray(3)
+        SensorManager.getOrientation(rotationMatrix, orientation)
+
+        val newAzimuth = normalizeAzimuth(Math.toDegrees(orientation[0].toDouble()))
+        updateAzimuth(newAzimuth)
+    }
+
+    private fun processCompass() {
+        if (gravity.any { it == 0f } || geomagnetic.any { it == 0f }) return // Avoid invalid readings
+
+        if (SensorManager.getRotationMatrix(rotationMatrix, inclinationMatrix, gravity, geomagnetic)) {
+            val orientation = FloatArray(3)
+            SensorManager.getOrientation(rotationMatrix, orientation)
 
-            val success = SensorManager.getRotationMatrix(R, I, mGravity, mGeomagnetic)
-            if (success) {
-                val orientation = FloatArray(3)
-                SensorManager.getOrientation(R, orientation)
-                var newAzimuth = calculateHeading(orientation[0])
-
-                Log.d(NAME, "Raw azimuth: $newAzimuth")
-
-                val display = getDisplay()
-                display?.let {
-                    val rotation = it.rotation
-                    newAzimuth = when (rotation) {
-                        Surface.ROTATION_90 -> (newAzimuth + 270) % 360 // Fix for landscape-right
-                        Surface.ROTATION_270 -> (newAzimuth + 90) % 360 // Fix for landscape-left
-                        Surface.ROTATION_180 -> (newAzimuth + 180) % 360 // Fix for upside-down
-                        else -> newAzimuth // Default for portrait
-                    }
-                }
-
-                Log.d(NAME, "Adjusted azimuth after rotation: $newAzimuth")
-
-                if (abs(mAzimuth - newAzimuth) > mFilter) {
-                    mAzimuth = newAzimuth.toInt()
-                    val params = Arguments.createMap().apply {
-                        putDouble("heading", mAzimuth.toDouble())
-                        putDouble("accuracy", 1.0)
-                    }
-                    reactApplicationContext
-                        .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
-                        .emit("HeadingUpdated", params)
-                    Log.d(NAME, "Emitting HeadingUpdated event with azimuth: $mAzimuth")
-                }
+            val newAzimuth = normalizeAzimuth(Math.toDegrees(orientation[0].toDouble()))
+            updateAzimuth(newAzimuth)
+        }
+    }
+
+    private fun updateAzimuth(newAzimuth: Double) {
+        val display = getDisplay()
+        val adjustedAzimuth = when (display?.rotation) {
+            Surface.ROTATION_90 -> (newAzimuth + 270) % 360
+            Surface.ROTATION_270 -> (newAzimuth + 90) % 360
+            Surface.ROTATION_180 -> (newAzimuth + 180) % 360
+            else -> newAzimuth
+        }
+
+        if (abs(azimuth - adjustedAzimuth) > filterThreshold) {
+            azimuth = adjustedAzimuth
+            val params = Arguments.createMap().apply {
+                putDouble("heading", azimuth)
+                putDouble("accuracy", 1.0)
             }
+            reactApplicationContext
+                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
+                .emit("HeadingUpdated", params)
+            Log.d(NAME, "Emitting HeadingUpdated: $azimuth")
         }
     }
 
-    override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {}
+    private fun normalizeAzimuth(azimuth: Double): Double {
+        return if (azimuth < 0) azimuth + 360 else azimuth
+    }
 
     private fun getDisplay(): Display? {
         return if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {
             reactApplicationContext.currentActivity?.display
         } else {
-            (mApplicationContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay
+            @Suppress("DEPRECATION")
+            (appContext.getSystemService(Context.WINDOW_SERVICE) as WindowManager).defaultDisplay
         }
     }
 
-    private fun calculateHeading(azimuth: Float): Double {
-        // Convert azimuth from radians to degrees
-        var heading = Math.toDegrees(azimuth.toDouble())
-
-        // Normalize the heading to [0, 360)
-        if (heading < 0) {
-            heading += 360
-        }
-        return heading
-    }
+    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {}
 }
\ No newline at end of file
diff --git a/node_modules/react-native-compass-heading/lib/commonjs/index.js b/node_modules/react-native-compass-heading/lib/commonjs/index.js
index f7803c1..045da06 100644
--- a/node_modules/react-native-compass-heading/lib/commonjs/index.js
+++ b/node_modules/react-native-compass-heading/lib/commonjs/index.js
@@ -24,7 +24,6 @@ CompassHeading.start = async (update_rate, callback) => {
   }
   const compassEventEmitter = new _reactNative.NativeEventEmitter(CompassHeading);
   listener = compassEventEmitter.addListener('HeadingUpdated', data => {
-    console.log('Received heading update:', data); // Debug incoming data
     callback(data);
   });
   const result = await _start(update_rate === null ? 0 : update_rate);
diff --git a/node_modules/react-native-compass-heading/lib/module/index.js b/node_modules/react-native-compass-heading/lib/module/index.js
index 6686ae2..91375f2 100644
--- a/node_modules/react-native-compass-heading/lib/module/index.js
+++ b/node_modules/react-native-compass-heading/lib/module/index.js
@@ -20,7 +20,6 @@ CompassHeading.start = async (update_rate, callback) => {
   }
   const compassEventEmitter = new NativeEventEmitter(CompassHeading);
   listener = compassEventEmitter.addListener('HeadingUpdated', data => {
-    console.log('Received heading update:', data); // Debug incoming data
     callback(data);
   });
   const result = await _start(update_rate === null ? 0 : update_rate);
diff --git a/node_modules/react-native-compass-heading/src/index.tsx b/node_modules/react-native-compass-heading/src/index.tsx
index 89db6a0..8ac785f 100644
--- a/node_modules/react-native-compass-heading/src/index.tsx
+++ b/node_modules/react-native-compass-heading/src/index.tsx
@@ -41,7 +41,6 @@ CompassHeading.start = async (
   listener = compassEventEmitter.addListener(
     'HeadingUpdated',
     (data: dataType) => {
-      console.log('Received heading update:', data); // Debug incoming data
       callback(data);
     }
   );
